{"ast":null,"code":"// imageWorker.js\n\nself.onmessage = async e => {\n  const {\n    fileDataURL,\n    maxWidth = 300,\n    quality = 0.6\n  } = e.data;\n  try {\n    const img = await loadImage(fileDataURL);\n    const compressedBase64 = compressImage(img, maxWidth, quality);\n    self.postMessage({\n      compressedBase64\n    });\n  } catch (error) {\n    self.postMessage({\n      error: error.message || \"Error in worker\"\n    });\n  }\n};\nfunction loadImage(dataURL) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = () => reject(new Error(\"Failed to load image\"));\n    img.src = dataURL;\n  });\n}\nfunction compressImage(img, maxWidth, quality) {\n  const scaleSize = maxWidth / img.width;\n  const canvas = new OffscreenCanvas(maxWidth, img.height * scaleSize);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n  // OffscreenCanvas supports convertToBlob for better async processing\n  const blob = canvas.convertToBlob({\n    type: \"image/jpeg\",\n    quality\n  });\n\n  // Но у вебворкера нет toDataURL, надо в основном потоке\n  // Поэтому возвращаем Blob и в основном потоке конвертим в base64\n\n  // В данном случае, чтобы проще, конвертим в base64 через FileReader здесь (если OffscreenCanvas не поддерживается, fallback к обычному canvas будет)\n\n  // Если OffscreenCanvas не поддерживается, fallback к обычному canvas:\n  // (но OffscreenCanvas хорошо работает в воркерах)\n\n  return null; // сделаем в сервисе\n}","map":{"version":3,"names":["self","onmessage","e","fileDataURL","maxWidth","quality","data","img","loadImage","compressedBase64","compressImage","postMessage","error","message","dataURL","Promise","resolve","reject","Image","onload","onerror","Error","src","scaleSize","width","canvas","OffscreenCanvas","height","ctx","getContext","drawImage","blob","convertToBlob","type"],"sources":["/Users/alnura/Desktop/BookStore-React/src/pages/profile/Profile.js"],"sourcesContent":["// imageWorker.js\n\nself.onmessage = async (e) => {\n  const { fileDataURL, maxWidth = 300, quality = 0.6 } = e.data;\n\n  try {\n    const img = await loadImage(fileDataURL);\n    const compressedBase64 = compressImage(img, maxWidth, quality);\n    self.postMessage({ compressedBase64 });\n  } catch (error) {\n    self.postMessage({ error: error.message || \"Error in worker\" });\n  }\n};\n\nfunction loadImage(dataURL) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = () => reject(new Error(\"Failed to load image\"));\n    img.src = dataURL;\n  });\n}\n\nfunction compressImage(img, maxWidth, quality) {\n  const scaleSize = maxWidth / img.width;\n  const canvas = new OffscreenCanvas(maxWidth, img.height * scaleSize);\n  const ctx = canvas.getContext(\"2d\");\n\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n  // OffscreenCanvas supports convertToBlob for better async processing\n  const blob = canvas.convertToBlob({ type: \"image/jpeg\", quality });\n\n  // Но у вебворкера нет toDataURL, надо в основном потоке\n  // Поэтому возвращаем Blob и в основном потоке конвертим в base64\n\n  // В данном случае, чтобы проще, конвертим в base64 через FileReader здесь (если OffscreenCanvas не поддерживается, fallback к обычному canvas будет)\n\n  // Если OffscreenCanvas не поддерживается, fallback к обычному canvas:\n  // (но OffscreenCanvas хорошо работает в воркерах)\n\n  return null; // сделаем в сервисе\n}"],"mappings":"AAAA;;AAEAA,IAAI,CAACC,SAAS,GAAG,MAAOC,CAAC,IAAK;EAC5B,MAAM;IAAEC,WAAW;IAAEC,QAAQ,GAAG,GAAG;IAAEC,OAAO,GAAG;EAAI,CAAC,GAAGH,CAAC,CAACI,IAAI;EAE7D,IAAI;IACF,MAAMC,GAAG,GAAG,MAAMC,SAAS,CAACL,WAAW,CAAC;IACxC,MAAMM,gBAAgB,GAAGC,aAAa,CAACH,GAAG,EAAEH,QAAQ,EAAEC,OAAO,CAAC;IAC9DL,IAAI,CAACW,WAAW,CAAC;MAAEF;IAAiB,CAAC,CAAC;EACxC,CAAC,CAAC,OAAOG,KAAK,EAAE;IACdZ,IAAI,CAACW,WAAW,CAAC;MAAEC,KAAK,EAAEA,KAAK,CAACC,OAAO,IAAI;IAAkB,CAAC,CAAC;EACjE;AACF,CAAC;AAED,SAASL,SAASA,CAACM,OAAO,EAAE;EAC1B,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMV,GAAG,GAAG,IAAIW,KAAK,CAAC,CAAC;IACvBX,GAAG,CAACY,MAAM,GAAG,MAAMH,OAAO,CAACT,GAAG,CAAC;IAC/BA,GAAG,CAACa,OAAO,GAAG,MAAMH,MAAM,CAAC,IAAII,KAAK,CAAC,sBAAsB,CAAC,CAAC;IAC7Dd,GAAG,CAACe,GAAG,GAAGR,OAAO;EACnB,CAAC,CAAC;AACJ;AAEA,SAASJ,aAAaA,CAACH,GAAG,EAAEH,QAAQ,EAAEC,OAAO,EAAE;EAC7C,MAAMkB,SAAS,GAAGnB,QAAQ,GAAGG,GAAG,CAACiB,KAAK;EACtC,MAAMC,MAAM,GAAG,IAAIC,eAAe,CAACtB,QAAQ,EAAEG,GAAG,CAACoB,MAAM,GAAGJ,SAAS,CAAC;EACpE,MAAMK,GAAG,GAAGH,MAAM,CAACI,UAAU,CAAC,IAAI,CAAC;EAEnCD,GAAG,CAACE,SAAS,CAACvB,GAAG,EAAE,CAAC,EAAE,CAAC,EAAEkB,MAAM,CAACD,KAAK,EAAEC,MAAM,CAACE,MAAM,CAAC;EACrD;EACA,MAAMI,IAAI,GAAGN,MAAM,CAACO,aAAa,CAAC;IAAEC,IAAI,EAAE,YAAY;IAAE5B;EAAQ,CAAC,CAAC;;EAElE;EACA;;EAEA;;EAEA;EACA;;EAEA,OAAO,IAAI,CAAC,CAAC;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}